---
title: 从StringBuffer和StringBuilder扩展开的问题
date: 2020-03-14 14:37:51
tags: java
---

# 从StringBuffer和StringBuilder扩展开的问题
> 原文来自[https://www.hollischuang.com/archives/3912](https://www.hollischuang.com/archives/3912) 。这里里面本来是有很多从一个问题开始详细扩展讲解的文章，但是当我转载的时候发现已经404了，很是可惜。
> 
<!--more-->
> 看了很多公众号的文章，发现有些喜欢起一些比较高大上的名字。比如这个原文的名字就是《国内Java面试总是问StringBuffer，StringBuilder区别是啥？档次为什么这么低？》，类似的名字还有《又一次过亿级架构事故发生了！》《高并发、微服务为什么一定要用 Docker 和 K8S ?》
> 这种名字有些类似于UC小编的震惊体，而且后面两个点进去之后是推销课程的广告。其实作为一个技术类型的文章，直接了当的把内容总结在标题上还是更加的易于阅读和寻找。

## 全部问题
标题上的问题是一个开场基础，可扩展为：

1. StringBuffer，StringBuilder区别是啥？ 

2. 什么是线程安全？

3. 如何保证线程安全？

4. 什么是锁？死锁？

5. synchronized的实现原理是什么？

6. 有了synchronized，还要volatile干什么？

7. synchronized的锁优化是怎么回事？（锁粗化？锁消除？自旋锁？偏向锁？轻量级锁？）

8. 知道JMM吗？（原子性？可见性？有序性？）

9. Java并发包了解吗？

10. 那什么是fail-fast？什么是fail-safe？

11. 什么是CopyOnWrite？

12. 那AQS呢？那CAS呢？

13. CAS都知道，那乐观锁一定知道了？

14. 乐观锁悲观锁区别是什么？

15. 数据库如何实现悲观锁和乐观锁？

16. 数据库锁有了解么？行级锁？表级锁？共享锁？排他锁？gap锁？next-key lock？

17. 数据库锁和隔离级别有什么关系？

18. 数据库锁和索引有什么关系？

19. 什么是聚簇索引？非聚簇索引？最左前缀是什么？B+树索引？联合索引？回表？

20. 分布式锁有了解吗？

21. Redis怎么实现分布式锁？

22. 为什么要用Redis？

23. Redis和memcache区别是什么？

24. Zookeeper怎么实现分布式锁？

25. 什么是Zookeeper？

26. 什么是CAP？

27. 什么是BASE？和CAP什么区别？

28. CAP怎么推导？如何取舍？

29. 分布式系统怎么保证数据一致性？

30. 啥是分布式事务？分布式事务方案？

31. 那么，最后了，来手写一个线程安全的单例吧？

32. 不用synchronized和lock能实现线程安全的单例吗？

33. 这你都能答上？那好吧，你给我解释下什么是Paxos算法吧？

## 部分问题答案
因为篇幅的缘故，原文的作者只是写了关键点，但是详细的文章大多数都404了。只好我以后再按照这个路线再找一找同类文章。

#### StringBuffer，StringBuilder区别是啥？
StringBuffer是线程安全的，而StringBuilder是非线程安全的。

#### 什么是线程安全？
线程安全是编程中的术语，指某个函数、函数库在并发环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成。即在多线程场景下，不发生有序性、原子性以及可见性问题。

#### 如何保证线程安全？
Java中主要通过加锁来实现线程安全。通常使用synchronized和Lock

#### 什么是锁？死锁？
死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。

死锁的发生必须具备以下四个必要条件：互斥条件、请求和保持条件、不剥夺条件、环路等待条件

死锁的解决办法就是破坏以上四种必备条件中的一个或者多个。

#### synchronized的实现原理是什么？
[http://www.hollischuang.com/archives/1883](http://www.hollischuang.com/archives/1883) 这篇文章是原文作者的

 主要说的是： 方法级的同步是隐式的。同步方法的常量池中会有一个`ACC_SYNCHRONIZED`标志。当某个线程要访问某个方法的时候，会检查是否有`ACC_SYNCHRONIZED`，如果有设置，则需要先获得监视器锁，然后开始执行方法，方法执行之后再释放监视器锁。这时如果其他线程来请求执行方法，会因为无法获得监视器锁而被阻断住。值得注意的是，如果在方法执行过程中，发生了异常，并且方法内部并没有处理该异常，那么在异常被抛到方法外面之前监视器锁会被自动释放。 

 同步代码块使用`monitorenter`和`monitorexit`两个指令实现。 总结为： 可以把执行monitorenter指令理解为加锁，执行monitorexit理解为释放锁。 每个对象维护着一个记录着被锁次数的计数器。未被锁定的对象的该计数器为0，当一个线程获得锁（执行monitorenter）后，该计数器自增变为 1 ，当同一个线程再次获得该对象的锁的时候，计数器再次自增。当同一个线程释放锁（执行monitorexit指令）的时候，计数器再自减。当计数器为0的时候。锁将被释放，其他线程便可以获得锁。
同步方法通过ACC_SYNCHRONIZED关键字隐式的对方法进行加锁。当线程要执行的方法被标注上ACC_SYNCHRONIZED时，需要先获得锁才能执行该方法。

同步代码块通过monitorenter和monitorexit执行来进行加锁。当线程执行到monitorenter的时候要先获得所锁，才能执行后面的方法。当线程执行到monitorexit的时候则要释放锁。

每个对象自身维护这一个被加锁次数的计数器，当计数器数字为0时表示可以被任意线程获得锁。当计数器不为0时，只有获得锁的线程才能再次获得锁。即可重入锁。

##### 扩展出的Monitor介绍
**管程** (英语：Monitors，也称为监视器) 是一种程序结构，结构内的多个子程序（对象或模块）形成的多个工作线程互斥访问共享资源。这些共享资源一般是硬件设备或一群变量。管程实现了在一个时间点，最多只有一个线程在执行管程的某个子程序。与那些通过修改数据结构实现互斥访问的并发程序设计相比，管程实现很大程度上简化了程序设计。 管程提供了一种机制，线程可以临时放弃互斥访问，等待某些条件得到满足后，重新获得执行权恢复它的互斥访问。

在多线程访问共享资源的时候，经常会带来可见性和原子性的安全问题。为了解决这类线程安全的问题，Java提供了同步机制、互斥锁机制，这个机制保证了在同一时刻只有一个线程能访问共享资源。这个机制的保障来源于监视锁Monitor，每个对象都拥有自己的监视锁Monitor。

先来举个例子，然后我们在上源码。我们可以把监视器理解为包含一个特殊的房间的建筑物，这个特殊房间同一时刻只能有一个客人（线程）。这个房间中包含了一些数据和代码。
![b1.png](1)

如果一个顾客想要进入这个特殊的房间，他首先需要在走廊（Entry Set）排队等待。调度器将基于某个标准（比如 FIFO）来选择排队的客户进入房间。如果，因为某些原因，该客户客户暂时因为其他事情无法脱身（线程被挂起），那么他将被送到另外一间专门用来等待的房间（Wait Set），这个房间的可以可以在稍后再次进入那件特殊的房间。如上面所说，这个建筑屋中一共有三个场所。
![b2.png](2)

总之，监视器是一个用来监视这些线程进入特殊的房间的。他的义务是保证（同一时间）只有一个线程可以访问被保护的数据和代码。

Monitor其实是一种同步工具，也可以说是一种同步机制，它通常被描述为一个对象，主要特点是：
> 对象的所有方法都被“互斥”的执行。好比一个Monitor只有一个运行“许可”，任一个线程进入任何一个方法都需要获得这个“许可”，离开时把许可归还。
> 通常提供singal机制：允许正持有“许可”的线程暂时放弃“许可”，等待某个谓词成真（条件变量），而条件成立后，当前进程可以“通知”正在等待这个条件变量的线程，让他可以重新去获得运行许可。

#### 有了synchronized，还要volatile干什么？
volatile通常被比喻成”轻量级的synchronized“，volatile可以保证可见性和有序性，实现原理是通过内存屏障实现的。

volatile有一个重要的作用，是synchronized不具备的，那就是禁止指令重排序。这一特点在双重校验锁实现单例的时候有用到，虽然使用了synchronized关键字，但是如果不用volatile修饰单例对象，就会存在问题。

#### synchronized的锁优化是怎么回事？（锁粗化？锁消除？自旋锁？偏向锁？轻量级锁？）
取自原文作者[http://www.hollischuang.com/archives/2344](http://www.hollischuang.com/archives/2344) 。
这个内容过多分成了第二个文章，原文总结：

自Java 6/Java 7开始，Java虚拟机对内部锁的实现进行了一些优化。这些优化主要包括锁消除（Lock Elision）、锁粗化（Lock Coarsening）、偏向锁（Biased Locking）以及适应性自旋锁（Adaptive Locking）。这些优化仅在Java虚拟机server模式下起作用（即运行Java程序时我们可能需要在命令行中指定Java虚拟机参数“-server”以开启这些优化）。

本文主要介绍了自旋锁、锁粗化和锁消除的概念。在JIT编译过程中，虚拟机会根据情况使用这三种技术对锁进行优化，目的是减少锁的竞争，提升性能。

#### 知道JMM吗？（原子性？可见性？有序性？）
Java内存模型（Java Memory Model ,JMM）是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。
原文作者还有一篇详细说明的文章，[http://www.hollischuang.com/archives/2550](http://www.hollischuang.com/archives/2550)

#### Java并发包了解吗？
java.util.concurrent包(J.U.C)中包含的是java并发编程中有用的一些工具类，包括几个部分：

1、locks部分：包含在java.util.concurrent.locks包中，提供显式锁(互斥锁和速写锁)相关功能；

2、atomic部分：包含在java.util.concurrent.atomic包中，提供原子变量类相关的功能，是构建非阻塞算法的基础；

3、executor部分：散落在java.util.concurrent包中，提供线程池相关的功能；

4、collections部分：散落在java.util.concurrent包中，提供并发容器相关功能；

5、tools部分：散落在java.util.concurrent包中，提供同步工具类，如信号量、闭锁、栅栏等功能；

#### 那什么是fail-fast？什么是fail-safe？
我们通常说的Java中的fail-fast机制，默认指的是Java集合的一种错误检测机制。说白了就是在做系统设计的时候先考虑异常情况，一旦发生异常，直接停止并上报。当多个线程对部分集合进行结构上的改变的操作时，有可能会产生fail-fast机制，这个时候就会抛出ConcurrentModificationException。

ConcurrentModificationException，当方法检测到对象的并发修改，但不允许这种修改时就抛出该异常。

为了避免触发fail-fast机制，导致异常，我们可以使用Java中提供的一些采用了fail-safe机制的集合类。

这样的集合容器在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。

java.util.concurrent包下的容器都是fail-safe的，可以在多线程下并发使用，并发修改。同时也可以在foreach中进行add/remove 。

#### 什么是CopyOnWrite？
Copy-On-Write简称COW，是一种用于程序设计中的优化策略。其基本思路是，从一开始大家都在共享同一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略。

CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。

#### 那AQS呢？那CAS呢？
AQS(AbstractQueuedSynchronizer)，即队列同步器。它是构建锁或者其他同步组件的基础框架（如ReentrantLock、ReentrantReadWriteLock、Semaphore等），JUC并发包的作者（Doug Lea）期望它能够成为实现大部分同步需求的基础。它是JUC并发包中的核心基础组件。

CAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。

CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该位置的值。（在 CAS 的一些特殊情况下将仅返回 CAS 是否成功，而不提取当前值。）CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。”这其实和乐观锁的冲突检查+数据更新的原理是一样的。

####　CAS都知道，那乐观锁一定知道了？
乐观锁（ Optimistic Locking ） 相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。

相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。

实现数据版本有两种方式，第一种是使用版本号，第二种是使用时间戳。

#### 乐观锁悲观锁区别是什么？
原文作者[http://www.hollischuang.com/archives/934](http://www.hollischuang.com/archives/934) 。 同下

**悲观锁：**
当我们要对一个数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。

这种借助数据库锁机制在修改数据之前先锁定，再修改的方式被称之为悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）。

> 在关系数据库管理系统里，悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）是一种并发控制的方法。它可以阻止一个事务以影响其他用户的方式来修改数据。如果一个事务执行的操作都某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。
悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。

**乐观锁：**
> 在关系数据库管理系统里，乐观并发控制（又名“乐观锁”，Optimistic Concurrency Control，缩写“OCC”）是一种并发控制的方法。它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。乐观事务控制最早是由孔祥重（H.T.Kung）教授提出。

乐观锁（ Optimistic Locking ） 相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。

相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。

**总结：**
实现数据版本有两种方式，第一种是使用版本号，第二种是使用时间戳。

在乐观锁与悲观锁的选择上面，主要看下两者的区别以及适用场景就可以了。

1、乐观锁并未真正加锁，效率高。一旦锁的粒度掌握不好，更新失败的概率就会比较高，容易发生业务失败。

2、悲观锁依赖数据库锁，效率低。更新失败的概率比较低。

随着互联网三高架构（高并发、高性能、高可用）的提出，悲观锁已经越来越少的被使用到生产环境中了，尤其是并发量比较大的业务场景。


#### 数据库如何实现悲观锁和乐观锁？
原文作者[http://www.hollischuang.com/archives/934](http://www.hollischuang.com/archives/934) 。

#### 数据库锁有了解么？行级锁？表级锁？共享锁？排他锁？gap锁？next-key lock？
原文作者：
[MySQL中的行级锁,表级锁,页级锁](http://www.hollischuang.com/archives/914)
[MySQL中的共享锁与排他锁](http://www.hollischuang.com/archives/923)

#### 数据库锁和隔离级别有什么关系？
很多DBMS定义了多个不同的“事务隔离等级”来控制锁的程度和并发能力。

ANSI/ISO SQL定义的标准隔离级别有四种，从高到底依次为：可序列化(Serializable)、可重复读(Repeatable reads)、提交读(Read committed)、未提交读(Read uncommitted)。

#### 数据库锁和索引有什么关系？

在MySQL中，行级锁并不是直接锁记录，而是锁索引。索引分为主键索引和非主键索引两种，如果一条sql语句操作了主键索引，MySQL就会锁定这条主键索引；如果一条语句操作了非主键索引，MySQL会先锁定该非主键索引，再锁定相关的主键索引。

#### 什么是聚簇索引？非聚簇索引？最左前缀是什么？B+树索引？联合索引？回表？
主键索引的叶子节点存的是整行数据。在InnoDB中，主键索引也被称为聚簇索引（clustered index）

非主键索引的叶子节点的内容是主键的值，在InnoDB中，非主键索引也被称为非聚簇索引（secondary index）

当我们创建一个联合索引的时候，如(key1,key2,key3)，相当于创建了（key1）、(key1,key2)和(key1,key2,key3)三个索引，这就是最左匹配原则。

在 InnoDB 里，索引B+ Tree的叶子节点存储了整行数据的是主键索引。而索引B+ Tree的叶子节点存储了主键的值的是非主键索引。因为主键索引树的叶子节点直接就是我们要查询的整行数据了。而非主键索引的叶子节点是主键的值，查到主键的值以后，还需要再通过主键的值再进行一次查询，这个过程叫做回表。

#### 分布式锁有了解吗？
目前比较常用的有以下几种方案：

基于数据库实现分布式锁 基于缓存（redis，memcached，tair）实现分布式锁 基于Zookeeper实现分布式锁

#### Redis怎么实现分布式锁？
多个进程执行以下Redis命令：

SETNX lock.foo

如果 SETNX 返回1，说明该进程获得锁，SETNX将键 lock.foo 的值设置为锁的超时时间（当前时间 + 锁的有效时间）。 如果 SETNX 返回0，说明其他进程已经获得了锁，进程不能进入临界区。进程可以在一个循环中不断地尝试 SETNX 操作，以获得锁。

#### 为什么要用Redis？
分布式缓存，提升性能

#### Redis和memcache区别是什么？
1、存储方式：Memcache把数据全部存在内存之中，断电后会挂掉，数据不能超 过内存大小。Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启时可以再次加载进行使用。（RDB快照和AOF日志两 种持久化方式）。

2、Redis支持数据的备份，及master-slave模式的数据备份。

3、数据支持类型：Redis在数据支持上要比Memcache多得多。

4、使用底层模型不同：新版本的Redis直接自己构建了VM机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。

#### Zookeeper怎么实现分布式锁？

基于zookeeper临时有序节点可以实现的分布式锁。

大致思想即为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。

#### 什么是Zookeeper？
Zookeeper是一个开放源码的分布式服务协调组件，是Google Chubby的开源实现。是一个高性能的分布式数据一致性解决方案。他将那些复杂的、容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并提供一系列简单易用的接口给用户使用。

#### 什么是CAP？
CAP理论：一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。

#### 什么是BASE？和CAP什么区别？
BASE理论是对CAP理论的延伸，核心思想是即使无法做到强一致性（Strong Consistency，CAP的一致性就是强一致性），但应用可以采用适合的方式达到最终一致性（Eventual Consitency）。

BASE是指基本可用（Basically Available）、软状态（ Soft State）、最终一致性（ Eventual Consistency）。

#### CAP怎么推导？如何取舍？
对于涉及到钱财这样不能有一丝让步的场景，C必须保证。网络发生故障宁可停止服务，这是保证CP，舍弃A。比如前几年支付宝光缆被挖断的事件，在网络出现故障的时候，支付宝就在可用性和数据一致性之间选择了数据一致性，用户感受到的是支付宝系统长时间宕机，但是其实背后是无数的工程师在恢复数据，保证数数据的一致性。

对于其他场景，比较普遍的做法是选择可用性和分区容错性，舍弃强一致性，退而求其次使用最终一致性来保证数据的安全。

#### 啥是分布式事务？分布式事务方案？
分布式事务是指会涉及到操作多个数据库的事务。其实就是将对同一库事务的概念扩大到了对多个库的事务。目的是为了保证分布式系统中的数据一致性。分布式事务处理的关键是必须有一种方法可以知道事务在任何地方所做的所有动作，提交或回滚事务的决定必须产生统一的结果（全部提交或全部回滚）

#### 手写一个线程安全的单例吧？
原文地址[http://www.hollischuang.com/archives/205](http://www.hollischuang.com/archives/205)

#### 不用synchronized和lock能实现线程安全的单例吗？
借助CAS（AtomicReference）实现单例模式：
``` java
public class Singleton {
    private static final AtomicReference<Singleton> INSTANCE = new AtomicReference<Singleton>(); 

    private Singleton() {}

    public static Singleton getInstance() {
        for (;;) {
            Singleton singleton = INSTANCE.get();
            if (null != singleton) {
                return singleton;
            }

            singleton = new Singleton();
            if (INSTANCE.compareAndSet(null, singleton)) {
                return singleton;
            }
        }
    }
}
```
用CAS的好处在于不需要使用传统的锁机制来保证线程安全,CAS是一种基于忙等待的算法,依赖底层硬件的实现,相对于锁它没有线程切换和阻塞的额外消耗,可以支持较大的并行度。 CAS的一个重要缺点在于如果忙等待一直执行不成功(一直在死循环中),会对CPU造成较大的执行开销。

#### Paxos算法吧？
原文作者也没有详细说明。

### 总结
其实这整个一个推导过程可以分出很多个知识点，每个知识点又可以延伸，就形成了原文作者说的体系。这篇文章后面有很多的知识点我还没有涉及到，需要认真的去查阅一下相关的知识。

